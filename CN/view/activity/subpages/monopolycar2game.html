<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>monopolycar2game.lua</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <h1>monopolycar2game.lua</h1>
    <a href="index.html">返回主页</a>
    <pre><code class="language-lua">slot0 = class(&quot;MonopolyCar2Game&quot;)
slot1 = 100
slot2 = 50
slot3 = &quot;xinnongpaoche&quot;
slot4 = {
	&quot;yuekegongjue_2&quot;,
	&quot;dafeng_5&quot;,
	&quot;baerdimo_6&quot;
}
slot5 = {
	&quot;gaoxiong_5&quot;,
	&quot;aidang_5&quot;,
	&quot;xinnong_3&quot;,
	&quot;qiye_7&quot;
}
slot6 = {
	&quot;ruihe_3&quot;,
	&quot;xianghe_3&quot;,
	&quot;ougen_5&quot;,
	&quot;weiershiqinwang_3&quot;
}
slot7 = {
	xianghe_3 = &quot;dance&quot;,
	baerdimo_6 = &quot;stand2&quot;,
	xinnong_3 = &quot;stand2&quot;,
	dafeng_5 = &quot;stand2&quot;,
	weiershiqinwang_3 = &quot;stand2&quot;,
	ruihe_3 = &quot;stand2&quot;,
	qiye_7 = &quot;dance&quot;,
	ougen_5 = &quot;stand2&quot;,
	aidang_5 = &quot;dance&quot;,
	yuekegongjue_2 = &quot;stand2&quot;,
	gaoxiong_5 = &quot;dance&quot;
}
slot8 = 0.6
slot9 = &quot;ui/activityuipage/monopolycar2_atlas&quot;
slot10 = &quot;B-stand&quot;
slot11 = &quot;F-stand&quot;
slot12 = &quot;B-walk&quot;
slot13 = &quot;F-walk&quot;
slot14 = &quot;typeMoveUp&quot;
slot15 = &quot;typeMoveDown&quot;
slot16 = &quot;typeMoveLeft&quot;
slot17 = &quot;typeMoveRight&quot;
slot18 = {
	{
		5006,
		5007,
		5008,
		5009,
		5010
	},
	{
		5005,
		0,
		0,
		0,
		5011
	},
	{
		5004,
		0,
		0,
		0,
		5012
	},
	{
		5003,
		0,
		0,
		0,
		5013
	},
	{
		5002,
		0,
		0,
		0,
		5014
	},
	{
		2001,
		5018,
		5017,
		5016,
		5015
	}
}

slot0.Ctor = function(slot0, slot1, slot2, slot3)
	slot0._binder = slot1
	slot0._tf = slot2
	slot0._event = slot3

	slot0:initData()
	slot0:initUI()
	slot0:initEvent()
end

slot0.initData = function(slot0)
	slot0.leftCount = 0
	slot0.inAnimatedFlag = false
	slot0.mapCells = {}
	slot0.showCharNames = {}

	if uv0 and #uv0 &gt; 0 then
		table.insert(slot0.showCharNames, Clone(uv0[math.random(1, #uv0)]))
	end

	if uv1 and #uv1 &gt; 0 then
		table.insert(slot0.showCharNames, Clone(uv1[math.random(1, #uv1)]))
	end

	if uv2 and #uv2 &gt; 0 then
		table.insert(slot0.showCharNames, Clone(uv2[math.random(1, #uv2)]))
	end
end

slot0.initUI = function(slot0)
	slot0.tplMapCell = findTF(slot0._tf, &quot;tplMapCell&quot;)
	slot0.mapContainer = findTF(slot0._tf, &quot;mapContainer&quot;)
	slot0.char = findTF(slot0._tf, &quot;mapContainer/char&quot;)
	slot0.showChars = {}

	for slot4 = 1, 3 do
		table.insert(slot0.showChars, findTF(slot0._tf, &quot;showChar&quot; .. slot4))
	end

	setActive(slot0.char, false)

	slot0.btnStart = findTF(slot0._tf, &quot;btnStart&quot;)
	slot0.btnHelp = findTF(slot0._tf, &quot;btnHelp&quot;)
	slot0.btnRp = findTF(slot0._tf, &quot;btnRp&quot;)
	slot0.commonAnim = findTF(slot0.btnRp, &quot;rpAni&quot;):GetComponent(typeof(Animator))
	slot0.labelLeftCountTip = findTF(slot0.btnStart, &quot;labelLeftCountTip&quot;)

	setActive(slot0.labelLeftCountTip, false)

	slot0.labelLeftCount = findTF(slot0.btnStart, &quot;labelLeftCount&quot;)
	slot0.labelDropShip = findTF(slot0._tf, &quot;labelDropShip&quot;)
	slot0.labelLeftRpCount = findTF(slot0._tf, &quot;labelLeftRpCount&quot;)
	slot0.rollStep = findTF(slot0._tf, &quot;step&quot;)

	setActive(slot0.rollStep, false)
	slot0:initMap()
	slot0:initChar()
end

slot0.initEvent = function(slot0)
	onButton(slot0._binder, slot0.btnStart, function ()
		if uv0.inAnimatedFlag then
			return
		end

		if uv0.leftCount and uv0.leftCount &lt;= 0 then
			pg.TipsMgr.GetInstance():ShowTips(i18n(&quot;common_count_noenough&quot;))

			return
		end

		slot0 = uv0

		slot0:changeAnimeState(true)
		setActive(uv0.btnStart, true)

		slot0 = uv0._event

		slot0:emit(MonopolyCar2Page.ON_START, uv0.activity.id, function (slot0)
			if slot0 and slot0 &gt; 0 then
				uv0:showRollAnimated(slot0)
			end
		end)
	end, SFX_PANEL)

	slot4 = function()
		pg.MsgboxMgr.GetInstance():ShowMsgBox({
			type = MSGBOX_TYPE_HELP,
			helps = pg.gametip.help_monopoly_car_2.tip
		})
	end

	onButton(slot0._binder, slot0.btnHelp, slot4, SFX_PANEL)

	for slot4 = 1, #slot0.showChars do
		onButton(slot0._binder, slot0.showChars[slot4], function ()
			uv0._event:emit(ActivityMediator.EVENT_GO_SCENE, SCENE.SKINSHOP)
		end, SFX_PANEL)
	end

	onButton(slot0._binder, slot0.btnRp, function ()
		if uv0.leftAwardCnt &gt; 0 then
			uv0._event:emit(MonopolyCar2Page.ON_AWARD)
		end
	end, SFX_PANEL)
end

slot0.showRollAnimated = function(slot0, slot1)
	findTF(slot0.rollStep, &quot;stepArrow&quot;).localEulerAngles = Vector3(0, 0, 0)
	slot3 = findTF(slot0.rollStep, &quot;progress/bg&quot;)
	slot3:GetComponent(typeof(Image)).fillAmount = 0.1
	slot3 = findTF(slot0.rollStep, &quot;select/bg&quot;)
	slot3:GetComponent(typeof(Image)).fillAmount = 0.1

	setText(findTF(slot0.rollStep, &quot;labelRoll&quot;), &quot;0&quot;)
	seriesAsync({
		function (slot0)
			slot1 = LeanTween.value(go(uv0._tf), 1, 0, 0.2)
			slot1 = slot1:setOnUpdate(System.Action_float(function (slot0)
				uv0.btnStart:GetComponent(typeof(CanvasGroup)).alpha = slot0
			end))

			slot1:setOnComplete(System.Action(function ()
				setActive(uv0.btnStart, false)

				uv0.btnStart:GetComponent(typeof(CanvasGroup)).alpha = 1

				uv1()
			end))
		end,
		function (slot0)
			slot1 = LeanTween.value(go(uv0._tf), 0, 1, 0.2)
			slot1 = slot1:setOnUpdate(System.Action_float(function (slot0)
				uv0.rollStep:GetComponent(typeof(CanvasGroup)).alpha = slot0

				setActive(uv0.rollStep, true)
			end))

			slot1:setOnComplete(System.Action(function ()
				uv0()
			end))
		end,
		function (slot0)
			slot2 = uv0 / 6 * 0.62 / uv0
			slot3 = -uv0 * 31
			slot4 = LeanTween.value(go(uv1._tf), 0, 1, 0.7 + uv0 / 5)
			slot4 = slot4:setEase(LeanTweenType.easeOutCirc)
			slot4 = slot4:setOnUpdate(System.Action_float(function (slot0)
				findTF(uv0.rollStep, &quot;progress/bg&quot;):GetComponent(typeof(Image)).fillAmount = uv1 * slot0 + 0.13
				findTF(uv0.rollStep, &quot;select/bg&quot;):GetComponent(typeof(Image)).fillAmount = uv2 * math.floor(slot0 / (1 / uv3)) + 0.17

				setText(findTF(uv0.rollStep, &quot;labelRoll&quot;), math.floor(slot0 / (1 / uv3)))

				uv5.localEulerAngles = Vector3(0, 0, uv4 * slot0 - 13)
			end))

			slot4:setOnComplete(System.Action(function ()
				uv0()
			end))
		end,
		function (slot0)
			slot1 = LeanTween.value(go(uv0._tf), 1, 0, 0.3)

			slot1:setOnComplete(System.Action(function ()
				uv0()
			end))
		end,
		function (slot0)
			slot1 = LeanTween.value(go(uv0._tf), 1, 0, 0.3)
			slot1 = slot1:setOnUpdate(System.Action_float(function (slot0)
				uv0.rollStep:GetComponent(typeof(CanvasGroup)).alpha = slot0
			end))

			slot1:setOnComplete(System.Action(function ()
				setActive(uv0.rollStep, false)

				uv0.rollStep:GetComponent(typeof(CanvasGroup)).alpha = 1

				uv1()
			end))
		end
	}, function ()
		uv0.useCount = uv0.useCount + 1
		uv0.step = uv1

		if uv0.step &gt; 0 then
			slot0 = GetSpriteFromAtlas(uv2, uv0.step)
		end

		uv0:updataUI()
		uv0:checkCharActive()
	end)
end

slot0.checkCountStory = function(slot0, slot1)
	slot2 = slot0.useCount

	if _.detect(slot0.activity:getDataConfig(&quot;story&quot;) or {}, function (slot0)
		return slot0[1] == uv0
	end) then
		pg.NewStoryMgr.GetInstance():Play(slot5[2], slot1)
	else
		slot1()
	end
end

slot0.changeAnimeState = function(slot0, slot1)
	if slot1 then
		slot0.btnStart:GetComponent(typeof(Image)).raycastTarget = false
		slot0.inAnimatedFlag = true

		slot0._event:emit(ActivityMainScene.LOCK_ACT_MAIN, true)
	else
		slot0.inAnimatedFlag = false
		slot0.btnStart:GetComponent(typeof(Image)).raycastTarget = true

		slot0._event:emit(ActivityMainScene.LOCK_ACT_MAIN, false)
	end

	setActive(slot0.btnStart, not slot1)
end

slot0.initMap = function(slot0)
	slot0.mapCells = {}

	for slot5 = 1, #uv0 do
		slot6 = slot5 - 1
		slot7 = {
			x = -slot6 * uv1,
			y = -slot6 * uv2
		}

		for slot12 = 1, #slot1[slot5] do
			slot13 = slot12 - 1

			if slot8[slot12] &gt; 0 then
				slot15 = cloneTplTo(slot0.tplMapCell, slot0.mapContainer, tostring(slot14))
				slot16 = Vector2(uv1 * slot13 + slot7.x, -uv2 * slot13 + slot7.y)
				slot15.localPosition = slot16
				slot17 = pg.activity_event_monopoly_map[slot14].icon
				findTF(slot15, &quot;image&quot;):GetComponent(typeof(Image)).sprite = GetSpriteFromAtlas(uv3, slot17)
				slot19 = findTF(slot15, &quot;image&quot;):GetComponent(typeof(Image))

				slot19:SetNativeSize()
				table.insert(slot0.mapCells, {
					col = slot13,
					row = slot6,
					mapId = slot14,
					tf = slot15,
					icon = slot17,
					position = slot16
				})
			end
		end
	end

	table.sort(slot0.mapCells, function (slot0, slot1)
		return slot0.mapId &lt; slot1.mapId
	end)
end

slot0.initChar = function(slot0)
	slot1 = PoolMgr.GetInstance()
	slot4 = true

	slot1:GetSpineChar(uv0, slot4, function (slot0)
		uv0.model = slot0
		uv0.model.transform.localScale = Vector3.one
		uv0.model.transform.localPosition = Vector3.zero

		uv0.model.transform:SetParent(uv0.char, false)

		uv0.anim = uv0.model:GetComponent(typeof(SpineAnimUI))

		uv0:checkCharActive()

		if uv0.pos then
			uv0:updataCharDirect(uv0.pos, false)
		end
	end)

	slot0.showCharMods = {}

	for slot4 = 1, #slot0.showCharNames do
		slot6 = PoolMgr.GetInstance()

		slot6:GetSpineChar(slot0.showCharNames[slot4], true, function (slot0)
			slot0.transform.localScale = Vector3.one
			slot0.transform.localPosition = Vector3.zero

			slot0.transform:SetParent(uv0.showChars[uv1], false)

			slot1 = slot0:GetComponent(typeof(SpineAnimUI))

			if uv2[uv3] then
				slot1:SetAction(uv2[uv3], 0)
			else
				slot1:SetAction(&quot;stand&quot;, 0)
			end

			table.insert(uv0.showCharMods, slot0)
		end)
	end
end

slot0.updataCharDirect = function(slot0, slot1, slot2)
	if slot0.model then
		slot3 = slot0.mapCells[slot1].position
		slot4 = slot1 + 1 &gt; #slot0.mapCells and 1 or slot1 + 1
		slot5 = slot0.mapCells[slot4]
		slot6, slot7 = slot0:getMoveType(slot0.mapCells[slot1].mapId, slot0.mapCells[slot4].mapId, slot2)
		slot0.char.localScale = Vector3(slot7, slot0.char.localScale.y, slot0.char.localScale.z)

		slot0.anim:SetActionCallBack(nil)
		slot0.anim:SetAction(slot6, 0)
	end
end

slot0.getMoveType = function(slot0, slot1, slot2, slot3)
	slot5 = {}
	slot6 = {}

	for slot10 = 1, #uv0 do
		for slot15 = 1, #slot4[slot10] do
			if slot11[slot15] == slot1 then
				slot5 = {
					x = slot15,
					y = slot10
				}
			end

			if slot16 == slot2 then
				slot6 = {
					x = slot15,
					y = slot10
				}
			end
		end
	end

	slot7, slot8 = nil

	if slot5.y &lt; slot6.y then
		slot7 = slot3 and uv1 or uv2
		slot8 = uv3
	elseif slot6.y &lt; slot5.y then
		slot7 = slot3 and uv4 or uv5
		slot8 = uv3
	elseif slot5.x &lt; slot6.x then
		slot7 = slot3 and uv1 or uv2
		slot8 = -uv3
	elseif slot6.x &lt; slot5.x then
		slot7 = slot3 and uv4 or uv5
		slot8 = -uv3
	end

	return slot7, slot8
end

slot0.checkCharActive = function(slot0)
	if slot0.anim then
		if slot0.effectId and slot0.effectId &gt; 0 then
			slot0:changeAnimeState(true)
			slot0:checkEffect(function ()
				uv0:changeAnimeState(false)
				uv0:checkCharActive()
			end)
		elseif slot0.step and slot0.step &gt; 0 then
			slot0:changeAnimeState(true)
			slot0:checkStep(function ()
				uv0:changeAnimeState(false)
				uv0:checkCharActive()
			end)
		end
	end
end

slot0.firstUpdata = function(slot0, slot1)
	slot0:activityDataUpdata(slot1)
	slot0:updataUI()
	slot0:updataChar()
	slot0:checkCharActive()
end

slot0.updataActivity = function(slot0, slot1)
	slot0:activityDataUpdata(slot1)
	slot0:updataUI()
end

slot0.activityDataUpdata = function(slot0, slot1)
	slot0.activity = slot1
	slot0.totalCnt = math.ceil((pg.TimeMgr.GetInstance():GetServerTime() - slot0.activity.data1) / 86400) * slot0.activity:getDataConfig(&quot;daily_time&quot;) + slot0.activity.data1_list[1]
	slot0.useCount = slot0.activity.data1_list[2]
	slot0.leftCount = slot0.totalCnt - slot0.useCount
	slot0.turnCnt = slot0.activity.data1_list[3] - 1
	slot0.leftDropShipCnt = 8 - slot0.turnCnt
	slot0.advanceTotalCnt = #slot1:getDataConfig(&quot;reward&quot;)
	slot0.isAdvanceRp = slot0.advanceTotalCnt - slot0.activity.data2_list[2] &gt; 0
	slot9 = slot0.activity.data2_list[1]
	slot0.leftAwardCnt = slot9 - slot8
	slot0.advanceRpCount = math.max(0, math.min(slot9, slot0.advanceTotalCnt) - slot8)
	slot0.commonRpCount = math.max(0, slot9 - slot0.advanceTotalCnt) - math.max(0, slot8 - slot0.advanceTotalCnt)
	slot10 = slot1:getDataConfig(&quot;reward_time&quot;)
	slot0.nextredPacketStep = slot10 - slot0.useCount % slot10
	slot0.pos = slot0.activity.data2
	slot0.step = slot0.activity.data3
	slot0.effectId = slot0.activity.data4
end

slot0.checkStep = function(slot0, slot1)
	if slot0.step &gt; 0 then
		slot2 = slot0._event

		slot2:emit(MonopolyCar2Page.ON_MOVE, slot0.activity.id, function (slot0, slot1, slot2)
			uv0.step = slot0
			uv0.pos = slot1[#slot1]
			uv0.effectId = slot2

			seriesAsync({
				function (slot0)
					uv0:moveCharWithPaths(uv1, nil, slot0)
				end,
				function (slot0)
					uv0:checkEffect(slot0)
				end
			}, function ()
				if uv0 then
					uv0()
				end
			end)
		end)
	elseif slot1 then
		slot1()
	end
end

slot0.updataUI = function(slot0)
	setText(slot0.labelLeftRpCount, &quot;&quot; .. slot0.leftAwardCnt)
	slot0.commonAnim:SetInteger(&quot;count&quot;, slot0.leftAwardCnt)
	setText(slot0.labelDropShip, &quot;&quot; .. slot0.turnCnt + 1)
	setText(slot0.labelLeftCountTip, i18n(&quot;monopoly_left_count&quot;))
	setText(slot0.labelLeftCount, slot0.leftCount)
end

slot0.updataChar = function(slot0)
	slot0.char.localPosition = slot0.mapCells[slot0.pos].position

	if not isActive(slot0.char) then
		SetActive(slot0.char, true)
		slot0.char:SetAsLastSibling()
	end

	if slot0.model then
		slot0:updataCharDirect(slot0.pos, false)
	end
end

slot0.checkEffect = function(slot0, slot1)
	if slot0.effectId &gt; 0 then
		slot2 = slot0.mapCells[slot0.pos]
		slot3 = pg.activity_event_monopoly_event[slot0.effectId].story

		seriesAsync({
			function (slot0)
				if uv0 and tonumber(uv0) ~= 0 then
					pg.NewStoryMgr.GetInstance():Play(uv0, slot0, true, true)
				else
					slot0()
				end
			end,
			function (slot0)
				uv0:triggerEfeect(slot0)
			end,
			function (slot0)
				uv0:checkCountStory(slot0)
			end
		}, slot1)

		return
	end

	if slot1 then
		slot1()
	end
end

slot0.triggerEfeect = function(slot0, slot1)
	slot2 = slot0._event

	slot2:emit(MonopolyCar2Page.ON_TRIGGER, slot0.activity.id, function (slot0, slot1)
		if slot0 and #slot0 &gt;= 0 then
			uv0.effectId = slot1
			uv0.pos = slot0[#slot0]

			seriesAsync({
				function (slot0)
					uv0:moveCharWithPaths(uv1, nil, slot0)
				end
			}, function ()
				uv0()
			end)
		end
	end)
end

slot0.moveCarWithPaths = function(slot0, slot1, slot2, slot3)
	if not slot1 or #slot1 &lt;= 0 then
		if slot3 then
			slot3()
		end

		return
	end

	slot4 = {}
	slot5 = slot0.char.localPosition
	slot6 = {}
	slot7 = {}

	for slot11 = 1, #slot1 do
		if slot0:checkPathTurn(slot1[slot11]) then
			table.insert(slot6, slot0.mapCells[slot1[slot11]].position)
			table.insert(slot7, slot1[slot11])
		elseif slot11 == #slot1 then
			table.insert(slot6, slot0.mapCells[slot1[slot11]].position)
			table.insert(slot7, slot1[slot11])
		end
	end

	slot0.speedX = 0
	slot0.speedY = 0
	slot0.baseSpeed = 6
	slot0.baseASpeed = 0.1

	if not slot0.timer then
		slot0.timer = Timer.New(function ()
			uv0:toMoveCar()
		end, 0.016666666666666666, -1)

		slot0.timer:Start()
	end

	for slot11 = 1, #slot6 do
		table.insert(slot4, function (slot0)
			uv0.moveComplete = slot0
			uv0.stopOnEnd = false
			uv0.targetPosition = uv1[uv2]
			uv0.targetPosIndex = uv3[uv2]
			uv0.moveX = uv0.targetPosition.x - uv0.char.localPosition.x
			uv0.moveY = uv0.targetPosition.y - uv0.char.localPosition.y
			uv0.baseSpeedX = uv0.baseSpeed * uv0.moveX / math.abs(uv0.moveX)
			uv0.baseASpeedX = uv0.baseASpeed * uv0.moveX / math.abs(uv0.moveX)
			uv0.baseSpeedY = math.abs(uv0.baseSpeedX) / (math.abs(uv0.moveX) / uv0.moveY)
			uv0.baseASpeedY = math.abs(uv0.baseASpeedX) / (math.abs(uv0.moveX) / uv0.moveY)

			if uv2 == 1 then
				uv0.speedX = 0
				uv0.speedY = 0
			else
				uv0.speedX = uv0.baseSpeedX
				uv0.speedY = uv0.baseSpeedY
			end
		end)
	end

	table.insert(slot4, function (slot0)
		uv0.moveComplete = nil

		uv0:updataCharDirect(uv1[#uv1], false)
		slot0()
	end)
	table.insert(slot4, function (slot0)
		slot1 = LeanTween.value(go(uv0._tf), 1, 0, 0.1)

		slot1:setOnComplete(System.Action(function ()
			uv0()
		end))
	end)
	seriesAsync(slot4, slot3)
end

slot0.toMoveCar = function(slot0)
	if not slot0.targetPosition then
		return
	end

	slot2 = math.abs(slot0.targetPosition.y - slot0.char.localPosition.y)

	if math.abs(slot0.targetPosition.x - slot0.char.localPosition.x) &lt;= 6.5 and slot2 &lt;= 6.5 then
		slot0.targetPosition = nil

		if slot0.moveComplete then
			slot0:updataCharDirect(slot0.targetPosIndex, true)
			slot0.moveComplete()
		end
	end

	slot0.speedX = math.abs(slot0.baseSpeedX) &lt; math.abs(slot0.speedX + slot0.baseASpeedX) and slot0.baseSpeedX or slot0.speedX + slot0.baseASpeedX
	slot0.speedY = math.abs(slot0.baseSpeedY) &lt; math.abs(slot0.speedY + slot0.baseASpeedY) and slot0.baseSpeedY or slot0.speedY + slot0.baseASpeedY
	slot3 = slot0.char.localPosition
	slot0.char.localPosition = Vector3(slot3.x + slot0.speedX, slot3.y + slot0.speedY, 0)
end

slot0.checkPathTurn = function(slot0, slot1)
	if slot0.mapCells[slot1 + 1 &gt; #slot0.mapCells and 1 or slot1 + 1].col == slot0.mapCells[slot1 - 1 &lt; 1 and #slot0.mapCells or slot1 - 1].col or slot0.mapCells[slot2].row == slot0.mapCells[slot3].row then
		return false
	end

	return true
end

slot0.moveCharWithPaths = function(slot0, slot1, slot2, slot3)
	slot0:moveCarWithPaths(slot1, slot2, slot3)

	return

	if not slot1 or #slot1 &lt;= 0 then
		if slot3 then
			slot3()
		end

		return
	end

	slot4 = {}
	slot5 = slot1[1] - 1 &lt; 1 and #slot0.mapCells or slot1[1] - 1

	for slot9 = 1, #slot1 do
		slot10 = slot0.mapCells[slot1[slot9]]

		table.insert(slot4, function (slot0)
			slot1 = uv0

			slot1:updataCharDirect(uv1, true)

			uv1 = uv2[uv3]
			slot2 = LeanTween.moveLocal(go(uv0.char), uv4.tf.localPosition, 0.35)
			slot2 = slot2:setEase(LeanTweenType.linear)

			slot2:setOnComplete(System.Action(function ()
				uv0()
			end))
		end)

		if slot9 == #slot1 then
			table.insert(slot4, function (slot0)
				uv0:updataCharDirect(uv1[uv2], false)
				slot0()
			end)
		end
	end

	seriesAsync(slot4, slot3)
end

slot0.dispose = function(slot0)
	slot4 = slot0.showModel

	PoolMgr.GetInstance():ReturnSpineChar(uv0, slot4)

	for slot4 = 1, 3 do
		if slot0.showCharNames[slot4] then
			PoolMgr.GetInstance():ReturnSpineChar(slot0.showCharNames[slot4], slot0.showCharMods[slot4])
		end
	end
end

return slot0
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</body>
</html>