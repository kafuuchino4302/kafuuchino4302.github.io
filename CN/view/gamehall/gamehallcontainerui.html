<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gamehallcontainerui.lua</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <h1>gamehallcontainerui.lua</h1>
    <a href="index.html">返回主页</a>
    <pre><code class="language-lua">slot0 = class(&quot;GameHallContainerUI&quot;)
slot1 = 4
slot2 = Vector3(0.7, 0.7, 0.7)
slot3 = &quot;mingshi&quot;
slot4 = 0.1
slot5 = 100
slot6 = 4
slot7, slot8 = nil
slot9 = 3256
slot10 = 1920
slot11 = {
	{
		&quot;item3&quot;,
		&quot;item3/spine&quot;
	}
}
slot12 = {
	{
		bound = &quot;item1/spine/bound&quot;,
		pos = &quot;item1/spine/pos&quot;,
		spine = &quot;item1/spine&quot;
	},
	{
		bound = &quot;item2/spine2/bound&quot;,
		pos = &quot;item2/spine2/pos&quot;,
		spine = &quot;item2/spine2&quot;
	},
	{
		bound = &quot;item2/spine3/bound&quot;,
		pos = &quot;item2/spine3/pos&quot;,
		spine = &quot;item2/spine3&quot;
	},
	{
		bound = &quot;item4/spine1/bound&quot;,
		pos = &quot;item4/spine1/pos&quot;,
		spine = &quot;item4/spine1&quot;
	},
	{
		bound = &quot;item4/spine2/bound&quot;,
		pos = &quot;item4/spine2/pos&quot;,
		spine = &quot;item4/spine2&quot;
	},
	{
		bound = &quot;item6/spine1/bound&quot;,
		pos = &quot;item6/spine1/pos&quot;,
		spine = &quot;item6/spine1&quot;
	},
	{
		bound = &quot;item6/spine2/bound&quot;,
		pos = &quot;item6/spine2/pos&quot;,
		spine = &quot;item6/spine2&quot;
	}
}

slot0.Ctor = function(slot0, slot1)
	uv2 = {
		uv0 - uv1 + pg.UIMgr.GetInstance().uiCamera.gameObject.transform:Find(&quot;Canvas&quot;).sizeDelta.x - uv0,
		0
	}
	uv3 = {
		0,
		0
	}
	slot0.container = slot1
	slot0.content = findTF(slot0.container, &quot;content&quot;)
	slot0.pos = findTF(slot0.content, &quot;pos&quot;)
	slot0.boundContainer = findTF(slot0.content, &quot;bound&quot;)
	slot0.charContentEvents = {}
	slot0.charContentCollider = {}
	slot0.items = {}

	for slot8 = 0, slot0.pos.childCount - 1 do
		table.insert(slot0.items, slot0.pos:GetChild(slot8))
	end

	slot0.sitItems = {}

	for slot8 = 1, #uv4 do
		slot9 = uv4[slot8]
		slot12 = GetComponent(findTF(slot0.pos, slot9.bound), typeof(BoxCollider2D))

		table.insert(slot0.sitItems, {
			sit = false,
			pos = findTF(slot0.pos, slot9.pos),
			min = slot0.pos:InverseTransformPoint(slot12.bounds.min),
			max = slot0.pos:InverseTransformPoint(slot12.bounds.max),
			anim = GetComponent(findTF(slot0.pos, slot9.spine), typeof(SpineAnimUI))
		})
	end

	slot7 = {}

	for slot11 = 1, #getProxy(BayProxy):getShips() do
		if not table.contains(slot7, slot6[slot11].name) then
			table.insert(slot7, slot6[slot11]:getPrefab())
		end
	end

	if uv5 &gt; #slot7 then
		uv5 = #slot7
	end

	slot0.chars = {}

	for slot11 = 1, uv5 do
		slot12 = slot11
		slot14 = PoolMgr.GetInstance()

		slot14:GetSpineChar(table.remove(slot7, math.random(1, #slot7)), true, function (slot0)
			slot1 = tf(slot0):GetComponent(typeof(SpineAnimUI))

			slot1:SetAction(&quot;stand2&quot;, 0)
			setParent(tf(slot0), uv0.pos)
			setLocalScale(slot0, uv1)

			slot3 = GetComponent(findTF(uv0.boundContainer, tostring(uv2)), typeof(BoxCollider2D))
			slot4 = uv0.pos:InverseTransformPoint(slot3.bounds.min)
			slot5 = uv0.pos:InverseTransformPoint(slot3.bounds.max)
			tf(slot0).anchoredPosition = uv0:getTargetPos(slot4, slot5)

			table.insert(uv0.chars, {
				tf = tf(slot0),
				anim = slot1,
				vel = Vector2(0, 0),
				bound = {
					slot4.x,
					slot4.y,
					slot5.x,
					slot5.y
				},
				min = slot4,
				max = slot5,
				pos = tf(slot0).anchoredPosition,
				curScale = tf(slot0).localScale
			})
			table.insert(uv0.items, tf(slot0))
		end)
	end

	slot0.bataiTf = findTF(slot0.pos, &quot;batai&quot;)
	slot0.coinChar = nil
	slot8 = PoolMgr.GetInstance()

	slot12 = function(slot0)
		uv0.coinChar = tf(slot0)

		tf(slot0):GetComponent(typeof(SpineAnimUI)):SetAction(&quot;stand2&quot;, 0)
		setParent(tf(slot0), findTF(uv0.bataiTf, &quot;char&quot;))
		setLocalScale(slot0, uv1)
	end

	slot8:GetSpineChar(uv7, true, slot12)

	slot0.content.anchoredPosition = Vector2(0, 0)
	slot8 = GetOrAddComponent(slot0.content, typeof(EventTriggerListener))
	slot0.velocityXSmoothing = Vector2(0, 0)
	slot0.offsetPosition = slot0.content.anchoredPosition

	slot8:AddBeginDragFunc(function (slot0, slot1)
		uv0.prevPosition = slot1.position
		uv0.scenePosition = uv0.content.anchoredPosition
		uv0.velocityXSmoothing = Vector2(0, 0)
		uv0.offsetPosition = uv0.content.anchoredPosition
	end)
	slot8:AddDragFunc(function (slot0, slot1)
		uv0.offsetPosition.x = slot1.position.x - uv0.prevPosition.x + uv0.scenePosition.x
		uv0.offsetPosition.y = slot1.position.y - uv0.prevPosition.y + uv0.scenePosition.y
		uv0.offsetPosition.x = uv1[2] &lt; uv0.offsetPosition.x and uv1[2] or uv0.offsetPosition.x
		uv0.offsetPosition.x = uv0.offsetPosition.x &lt; uv1[1] and uv1[1] or uv0.offsetPosition.x
		uv0.offsetPosition.y = uv2[2] &lt; uv0.offsetPosition.y and uv2[2] or uv0.offsetPosition.y
		uv0.offsetPosition.y = uv0.offsetPosition.y &lt; uv2[1] and uv2[1] or uv0.offsetPosition.y
	end)
	slot8:AddDragEndFunc(function (slot0, slot1)
	end)

	slot0.clickItems = {}

	for slot12 = 1, #uv8 do
		slot13 = findTF(slot0.pos, uv8[slot12][1])

		table.insert(slot0.clickItems, {
			time = 0,
			tf = slot13,
			anim = GetComponent(findTF(slot0.pos, uv8[slot12][2]), typeof(SpineAnimUI))
		})
		onButton(slot0._event, slot13, function ()
			if uv0:checkClickTime(uv1) then
				uv0:setAnimAction(uv1, &quot;action&quot;, 1, &quot;normal&quot;)
			end
		end)
	end
end

slot0.setCharSit = function(slot0, slot1, slot2)
	if slot1.sitFlag or slot2.sitFlag then
		return
	end

	slot3 = slot1.tf

	slot0:setAnimAction(slot1.anim, &quot;sit&quot;, 0, nil)
	slot0:setAnimAction(slot2.anim, &quot;sit&quot;, 0, nil)

	slot1.curAction = &quot;sit&quot;
	slot2.curAction = &quot;sit&quot;
	slot1.target = nil
	slot1.sitItem = slot2
	slot1.sitFlag = true
	slot1.time = math.random(10, 20)
	slot1.tf.localScale = uv0
	slot1.vel = Vector2(0, 0)
	slot2.sitFlag = true

	setParent(slot1.tf, slot2.pos)

	slot1.tf.anchoredPosition = Vector2(0, 0)
end

slot0.stopCharSit = function(slot0, slot1)
	slot1.sitItem.sitFlag = false

	slot0:setAnimAction(slot1.anim, &quot;walk&quot;, 0, nil)
	slot0:setAnimAction(slot1.sitItem.anim, &quot;normal&quot;, 0, nil)

	slot1.sitItem = nil
	slot1.sitFlag = false

	setParent(slot1.tf, slot0.pos)

	slot1.tf.anchoredPosition = slot1.pos
end

slot0.checkClickTime = function(slot0, slot1)
	for slot5 = 1, #slot0.clickItems do
		if slot0.clickItems[slot5].anim == slot1 and (slot0.clickItems[slot5].time == 0 or slot0.clickItems[slot5].time &lt; Time.realtimeSinceStartup) then
			slot0.clickItems[slot5].time = Time.realtimeSinceStartup + 2

			return true
		end
	end

	return false
end

slot0.step = function(slot0)
	slot4 = slot0.offsetPosition
	slot0.content.anchoredPosition, slot0.velocityXSmoothing = Vector2.SmoothDamp(slot0.content.anchoredPosition, slot4, slot0.velocityXSmoothing, uv0)

	for slot4 = 1, #slot0.chars do
		slot5 = slot0.chars[slot4]
		slot7 = slot5.pos

		if not slot5.time or slot6 &lt;= 0 then
			if slot5.sitFlag then
				slot0:stopCharSit(slot5)
			elseif math.random(1, 10) &gt; 5 then
				slot8 = slot0:getTargetPos(slot5.min, slot5.max)
				slot5.target = slot8
				slot5.vel = slot0:getVel(slot7, slot8)
			end

			slot5.time = math.random(1, uv1)
		end

		if slot5.target and not slot5.sitFlag then
			if ({
				slot5.vel.x * uv2 * Time.deltaTime,
				slot5.vel.y * uv2 * Time.deltaTime
			})[1] ~= 0 then
				slot5.pos.x = slot5.pos.x + slot8[1]
			end

			if slot8[2] ~= 0 then
				slot5.pos.y = slot5.pos.y + slot8[2]
			end

			if slot5.pos.x &lt; slot5.bound[1] then
				slot5.pos.x = slot9[1]
				slot5.vel.x = 0
			end

			if slot9[3] &lt; slot5.pos.x then
				slot5.pos.x = slot9[3]
				slot5.vel.x = 0
			end

			if slot5.pos.y &lt; slot9[2] then
				slot5.pos.y = slot9[2]
				slot5.vel.y = 0
			end

			if slot9[4] &lt; slot5.pos.y then
				slot5.pos.y = slot9[4]
				slot5.vel.y = 0
			end

			slot5.tf.anchoredPosition = slot5.pos
			slot10 = slot5.target

			if math.abs(slot5.target.x - slot5.pos.x) &lt; 10 then
				slot5.vel.x = 0
			end

			if math.abs(slot5.target.y - slot5.pos.y) &lt; 10 then
				slot5.vel.y = 0
			end
		end

		slot8 = true
		slot9 = slot5.sitFlag

		if slot5.vel.x == 0 and slot5.vel.y == 0 then
			slot5.time = slot5.time - Time.deltaTime
			slot8 = false
		end

		if not slot8 and slot5.target then
			slot5.target = nil
		end

		if not slot5.sitFlag and not slot8 then
			slot5.ableSit = true
		end

		if slot8 then
			if slot5.curAction ~= &quot;walk&quot; then
				slot5.curAction = &quot;walk&quot;

				slot5.anim:SetAction(&quot;walk&quot;, 0)
			end
		elseif slot9 then
			if slot5.curAction ~= &quot;sit&quot; then
				slot5.curAction = &quot;sit&quot;

				slot5.anim:SetAction(&quot;sit&quot;, 0)
			end
		elseif slot5.curAction ~= &quot;stand2&quot; then
			slot5.curAction = &quot;stand2&quot;

			slot5.anim:SetAction(&quot;stand2&quot;, 0)
		end

		if slot5.vel.x ~= 0 and slot5.curScale.x ~= (slot5.vel.x &gt; 0 and 1 or -1) then
			slot5.curScale.x = slot10 * uv3.x
			slot5.tf.localScale = slot5.curScale
		end

		if slot8 then
			slot0:checkCharSit(slot5)
		end
	end

	table.sort(slot0.items, function (slot0, slot1)
		if slot0.anchoredPosition.y &lt; slot1.anchoredPosition.y then
			return true
		end
	end)

	for slot4, slot5 in ipairs(slot0.items) do
		slot5:SetAsFirstSibling()
	end
end

slot0.checkCharSit = function(slot0, slot1)
	if not slot1.ableSit then
		return
	end

	slot2 = slot1.pos

	for slot6 = 1, #slot0.sitItems do
		slot7 = slot0.sitItems[slot6]
		slot9 = slot7.max

		if slot7.min.x &lt; slot2.x and slot2.x &lt; slot9.x and slot8.y &lt; slot2.y and slot2.y &lt; slot9.y then
			if math.random(1, 10) &gt; 7 then
				print(&quot;角色想坐下&quot;)
				slot0:setCharSit(slot1, slot7)
			else
				slot1.ableSit = false

				print(&quot;角色不想坐下&quot;)
			end
		end
	end
end

slot0.getVel = function(slot0, slot1, slot2)
	slot3 = math.atan(math.abs(slot2.y - slot1.y) / math.abs(slot2.x - slot1.x))

	return Vector2(math.cos(slot3) * (slot1.x &lt; slot2.x and 1 or -1), math.sin(slot3) * (slot1.y &lt; slot2.y and 1 or -1))
end

slot0.setAnimAction = function(slot0, slot1, slot2, slot3, slot4)
	slot1:SetActionCallBack(nil)
	slot1:SetAction(slot2, 0)
	slot1:SetActionCallBack(function (slot0)
		if slot0 == &quot;finish&quot; and uv0 == 1 then
			uv1:SetActionCallBack(nil)
			uv1:SetAction(uv2, 0)
		end
	end)
end

slot0.getTargetPos = function(slot0, slot1, slot2)
	return Vector2(slot1.x + math.random(1, tonumber(slot2.x) - tonumber(slot1.x)), slot1.y + math.random(1, tonumber(slot2.y) - tonumber(slot1.y)))
end

slot0.isPointInMatrix = function(slot0, slot1, slot2, slot3, slot4, slot5)
	return slot0:getCross(slot1, slot2, slot5) * slot0:getCross(slot3, slot4, slot5) &gt;= 0 and slot0:getCross(slot2, slot3, slot5) * slot0:getCross(slot4, slot1, slot5) &gt;= 0
end

return slot0
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</body>
</html>