<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gameroomcurlingview.lua</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <h1>gameroomcurlingview.lua</h1>
    <a href="index.html">返回主页</a>
    <pre><code class="language-lua">slot0 = class(&quot;GameRoomCurlingView&quot;, import(&quot;..BaseMiniGameView&quot;))
slot1 = &quot;event:/ui/ddldaoshu2&quot;
slot2 = &quot;event:/ui/taosheng&quot;
slot3 = &quot;event:/ui/minigame_hitcake&quot;
slot4 = &quot;event:/ui/zhengque&quot;
slot5 = &quot;event:/ui/shibai&quot;
slot6 = 1
slot7 = 2
slot8 = 3
slot9 = {
	20,
	40,
	60
}
slot10 = 4
slot11 = Vector2(-720, 0)
slot12 = {
	-250,
	250
}
slot13 = Vector2(-250, -42)
slot14 = {
	1,
	10,
	30
}
slot15 = 0.2
slot16 = false
slot17 = {
	cube = 0.2,
	miner = 0.2,
	walker = 0.1,
	oil = 0.2,
	wall = 0
}
slot18 = {
	cube = 2,
	miner = 2,
	walker = 2,
	oil = 2,
	wall = 0
}
slot19 = {
	0.5,
	5,
	10
}
slot20 = {
	0.5,
	5,
	10
}
slot21 = Vector2(400, -600)
slot22 = Vector2(400, 500)
slot27 = Vector2(617, -108)
slot28 = 0.7
slot29 = {
	111,
	222,
	333
}
slot30 = {
	3000,
	2000,
	1000
}
slot31 = 1
slot32 = 2
slot33 = 3
slot34 = 4
slot35 = {
	cube = 300,
	miner = 300,
	walker = 900,
	oil = 300,
	wall = 100
}
slot36 = 1
slot37 = {
	oil = {
		{
			appear = 0.8,
			num = 1
		},
		{
			appear = 0.1,
			num = 1
		}
	},
	cube = {
		{
			appear = 0.8,
			num = 1
		},
		{
			appear = 0.1,
			num = 1
		}
	},
	miner = {
		{
			appear = 1,
			num = 1
		},
		{
			appear = 0.1,
			num = 1
		}
	},
	walker = {
		appear = 1,
		path = {
			1,
			2,
			3,
			4
		}
	}
}
slot38 = {
	miner = 3.5,
	cube = 3.5,
	walker = 4.5,
	oil = 3.5
}
slot39 = true
slot40 = &quot;event_push&quot;
slot41 = &quot;event_speed&quot;
slot42 = &quot;event_hit&quot;
slot43 = &quot;event_result&quot;
slot44 = &quot;event_next&quot;
slot45 = &quot;event_game_pause&quot;
slot46 = &quot;event_game_resume&quot;
slot47 = &quot;event_add_score&quot;

slot48 = function(slot0, slot1)
	slot2 = {
		Ctor = function (slot0)
			slot0._tf = uv0
			slot0._event = uv1
			slot0.powerTF = findTF(slot0._tf, &quot;power&quot;)
			slot0.powerSlider = GetComponent(slot0.powerTF, typeof(Slider))

			slot0:InitPowerSlider()

			slot0.animator = GetComponent(slot0._tf, typeof(Animator))
			slot0.aniDft = GetComponent(slot0._tf, typeof(DftAniEvent))

			slot0.aniDft:SetTriggerEvent(function ()
				uv0:Push()
			end)

			slot0.dragTrigger = GetOrAddComponent(slot0._tf, &quot;EventTriggerListener&quot;)

			slot0.dragTrigger:AddPointDownFunc(function (slot0, slot1)
				if not uv0.canClick then
					return
				end

				uv0.canClick = false
				uv0.charging = true
				uv0.originScreenY = slot1.position.y
				uv0.originY = uv0._tf.anchoredPosition.y

				uv0:Charge()
			end)
			slot0.dragTrigger:AddDragFunc(function (slot0, slot1)
				if not uv0.charging then
					return
				end

				slot3 = uv1[1] &lt;= slot1.position.y - uv0.originScreenY + uv0.originY and slot3 or uv1[1]

				setLocalPosition(uv0._tf, Vector2(uv0._tf.anchoredPosition.x, slot3 &lt;= uv1[2] and slot3 or uv1[2]))
			end)
			slot0.dragTrigger:AddPointUpFunc(function (slot0, slot1)
				if not uv0.charging then
					return
				end

				uv0.charging = false

				uv0.animator:SetInteger(&quot;Throw&quot;, uv0.phase)
				uv0.animator:SetInteger(&quot;Charge&quot;, 0)
			end)
			slot0._event:bind(uv3, function (slot0, slot1, slot2)
				uv0.animator:SetInteger(&quot;Result&quot;, slot1.result)
			end)
			slot0._event:bind(uv4, function (slot0, slot1, slot2)
				uv0:Reset()
				uv0:Start()
			end)
			slot0:Reset()
		end,
		Start = function (slot0)
			slot0.canClick = true
		end,
		Reset = function (slot0)
			setActive(slot0.powerTF, false)
			setLocalPosition(slot0._tf, uv0)
			slot0.animator:SetInteger(&quot;Charge&quot;, 0)
			slot0.animator:SetInteger(&quot;Throw&quot;, 0)
			slot0.animator:SetInteger(&quot;Result&quot;, 0)
			slot0.animator:Play(&quot;WaitA&quot;)

			slot0.power = 0
			slot0.phase = 0
			slot0.charging = false
			slot0.canClick = false
			slot0.powerSlider.value = 0
		end,
		InitPowerSlider = function (slot0)
			slot1 = 24
			slot2 = 162
			findTF(slot0.powerTF, &quot;progress/green&quot;).sizeDelta = Vector2(uv0[1] / uv0[3] * slot2, slot1)
			findTF(slot0.powerTF, &quot;progress/green/yellow&quot;).sizeDelta = Vector2((uv0[2] - uv0[1]) / uv0[3] * slot2, slot1)
			findTF(slot0.powerTF, &quot;progress/green/yellow/red&quot;).sizeDelta = Vector2((uv0[3] - uv0[2]) / uv0[3] * slot2, slot1)
		end,
		Charge = function (slot0)
			setActive(slot0.powerTF, true)
			setActive(findTF(slot0.powerTF, &quot;binghu_huoyan&quot;), false)

			slot0.phase = uv0

			slot0.animator:SetInteger(&quot;Charge&quot;, slot0.phase)
			LeanTween.value(go(slot0._tf), slot0.power, uv1[3], uv2):setOnUpdate(System.Action_float(function (slot0)
				uv0.power = slot0
				uv0.powerSlider.value = uv0.power / uv1[3]

				if uv0.phase == uv2 and uv1[1] &lt;= uv0.power then
					uv0.phase = uv3

					uv0.animator:SetInteger(&quot;Charge&quot;, uv0.phase)
				elseif uv0.phase == uv3 and uv1[2] &lt;= uv0.power then
					uv0.phase = uv4

					uv0.animator:SetInteger(&quot;Charge&quot;, uv0.phase)
					setActive(findTF(uv0.powerTF, &quot;binghu_huoyan&quot;), true)
				end

				if not uv0.charging then
					LeanTween.cancel(go(uv0._tf))
				end
			end))
		end,
		Push = function (slot0)
			slot0._event:emit(uv0, {
				power = slot0.power
			})
			setActive(slot0.powerTF, false)
		end
	}

	slot2:Ctor()

	return slot2
end

slot49 = function(slot0, slot1, slot2)
	slot3 = {
		Ctor = function (slot0)
			slot0.tpls = uv0
			slot0._event = uv1
			slot0.player = uv2
			slot0.scene = slot0.player.parent

			slot0._event:bind(uv3, function (slot0, slot1, slot2)
				if uv0.isPush then
					return
				end

				uv0:Push(slot1.power)
			end)
			slot0._event:bind(uv4, function (slot0, slot1, slot2)
				uv0:Reset()
				uv0:Start()
			end)
			slot0._event:bind(uv5, function (slot0, slot1, slot2)
				uv0:Pause()
			end)
			slot0._event:bind(uv6, function (slot0, slot1, slot2)
				uv0:Resume()
			end)
			slot0:Reset()
		end,
		Start = function (slot0)
		end,
		RandomRole = function (slot0)
			if slot0._tf then
				slot0._tf:SetParent(slot0.tpls, false)
				setActive(slot0._tf, false)
			end

			slot0._tf = slot0.tpls:GetChild(math.random(1, 4) - 1)

			setActive(slot0._tf, true)

			slot0.speedTF = findTF(slot0._tf, &quot;speed&quot;)

			setActive(slot0.speedTF, uv0)

			slot0.animator = GetComponent(slot0._tf, typeof(Animator))
			slot0.rigbody = GetComponent(slot0._tf, &quot;Rigidbody2D&quot;)
			slot0.rigbody.velocity = Vector2.zero
			slot0.phyItem = GetComponent(slot0._tf, &quot;Physics2DItem&quot;)

			slot0.phyItem.CollisionEnter:RemoveAllListeners()
			slot0.phyItem.CollisionEnter:AddListener(function (slot0)
				uv0:OnCollision(slot0)
			end)
		end,
		Reset = function (slot0)
			slot0:RandomRole()

			slot0.rigbody.velocity = Vector2.zero

			slot0._tf:SetParent(findTF(slot0.player, &quot;chargePos&quot;), false)
			setText(slot0.speedTF, 0)
			setLocalPosition(slot0._tf, Vector2.zero)
			setLocalScale(slot0._tf, Vector2.one)
			slot0.animator:Play(&quot;Neutral&quot;)
			slot0.animator:SetBool(&quot;Stop&quot;, false)
			slot0.animator:SetInteger(&quot;Result&quot;, 0)
			slot0.animator:SetInteger(&quot;SpeedPhase&quot;, 0)

			slot0.isPush = false
			slot0.isStop = true
			slot0.phase = 0
		end,
		Step = function (slot0)
			if uv0 then
				setText(slot0.speedTF, slot0.rigbody.velocity:Magnitude())
			end

			if not slot0.isPush or slot0.isStop then
				return
			end

			slot1 = slot0:GetSpeed()

			slot0._event:emit(uv1, {
				speed = slot1
			})

			if uv2[1] &lt; slot1 then
				slot0.animator:SetInteger(&quot;SpeedPhase&quot;, 1)
			elseif uv2[2] &lt; slot1 then
				slot0.animator:SetInteger(&quot;SpeedPhase&quot;, 2)
			elseif uv2[3] &lt; slot1 then
				slot0.animator:SetInteger(&quot;SpeedPhase&quot;, 3)
			end

			if slot1 &lt; uv3 then
				slot0.animator:SetBool(&quot;Stop&quot;, true)

				slot0.isStop = true

				slot0:Result()
			end
		end,
		Push = function (slot0, slot1)
			pg.CriMgr.GetInstance():PlaySoundEffect_V3(uv0)

			slot0.isPush = true
			slot0.isStop = false

			slot0._tf:SetParent(slot0.scene, true)

			slot0.rigbody.velocity = Vector2(uv1.x - slot0._tf.anchoredPosition.x, uv1.y - slot0._tf.anchoredPosition.y):Normalize():Mul(slot1)

			slot0:Slip()
		end,
		Slip = function (slot0)
			slot0.animator:SetBool(&quot;Stop&quot;, false)

			slot0.isStop = false
		end,
		OnCollision = function (slot0, slot1)
			slot0.animator:SetTrigger(&quot;Hit&quot;)
			slot0._event:emit(uv0)
			pg.CriMgr.GetInstance():PlaySoundEffect_V3(uv1)

			slot3 = 0
			slot4 = Vector2(1, 0)
			slot5 = Vector2(slot0.rigbody.velocity.x, slot0.rigbody.velocity.y)

			if slot1.collider.gameObject.name == &quot;wall&quot; then
				slot5:Mul(uv2.wall)

				slot3 = uv3.wall

				slot4:Mul(uv4.wall)
			elseif slot2 == &quot;oil&quot; then
				slot5:Mul(uv2.oil)

				slot3 = uv3.oil

				slot4:Mul(uv4.oil)
			elseif slot2 == &quot;cube&quot; then
				slot5:Mul(uv2.cube)

				slot3 = uv3.cube

				slot4:Mul(uv4.cube)
			elseif slot2 == &quot;miner&quot; then
				slot5:Mul(uv2.miner)

				slot3 = uv3.miner

				slot4:Mul(uv4.miner)
			elseif slot2 == &quot;walker&quot; then
				slot5:Mul(uv2.walker)

				slot3 = uv3.walker

				slot4:Mul(uv4.walker)
			end

			slot0.rigbody.velocity = slot0.rigbody.velocity:Sub(slot5)
			slot0.rigbody.velocity = slot0.rigbody.velocity:Add(slot4)

			slot0._event:emit(uv5, {
				score = slot3,
				pos = slot0._tf.anchoredPosition
			})
		end,
		Result = function (slot0)
			slot3 = 0
			slot3 = Vector2.Distance(uv1, Vector2(slot0._tf.anchoredPosition.x, slot0._tf.anchoredPosition.y / uv0)) &lt;= uv2[1] and 1 or slot2 &lt;= uv2[2] and 2 or slot2 &lt;= uv2[3] and 3 or 4

			slot0.animator:SetInteger(&quot;Result&quot;, slot3)
			slot0._event:emit(uv3, {
				result = slot3
			})

			if slot3 == 0 or slot3 == 4 then
				pg.CriMgr.GetInstance():PlaySoundEffect_V3(uv4)
			else
				pg.CriMgr.GetInstance():PlaySoundEffect_V3(uv5)
			end
		end,
		Pause = function (slot0)
			slot0.speedRecord = slot0.rigbody.velocity
			slot0.rigbody.velocity = Vector2.zero
			slot0.animator.speed = 0
		end,
		Resume = function (slot0)
			slot0.rigbody.velocity = slot0.speedRecord
			slot0.animator.speed = 1
		end,
		GetSpeed = function (slot0)
			return slot0.rigbody.velocity:Magnitude()
		end
	}

	slot3:Ctor()

	return slot3
end

slot50 = function(slot0, slot1)
	slot2 = {
		Ctor = function (slot0)
			slot0._tf = uv0
			slot0._event = uv1
			slot0.animator = GetComponent(slot0._tf, typeof(Animator))

			slot0._event:bind(uv2, function (slot0, slot1, slot2)
				uv0:TurnLeft()
			end)
			slot0._event:bind(uv3, function (slot0, slot1, slot2)
				uv0:Hit()
			end)
			slot0._event:bind(uv4, function (slot0, slot1, slot2)
				uv0:Result(slot1.result)
			end)
			slot0._event:bind(uv5, function (slot0, slot1, slot2)
				uv0:Reset()
				uv0:Start()
			end)
		end,
		Start = function (slot0)
		end,
		Reset = function (slot0)
			slot0.animator:SetInteger(&quot;Result&quot;, 0)
			slot0.animator:Play(&quot;WaitA&quot;)
		end,
		TurnLeft = function (slot0)
			slot0.animator:SetTrigger(&quot;TurnLeft&quot;)
		end,
		Result = function (slot0, slot1)
			slot0.animator:SetInteger(&quot;Result&quot;, slot1)
		end,
		Hit = function (slot0)
			slot0.animator:SetTrigger(&quot;Hit&quot;)
		end
	}

	slot2:Ctor()

	return slot2
end

slot51 = function(slot0, slot1)
	slot2 = {
		Ctor = function (slot0)
			slot0._tf = uv0
			slot0._event = uv1
			slot0.animator = GetComponent(slot0._tf, typeof(Animator))

			slot0._event:bind(uv2, function (slot0, slot1, slot2)
				uv0:NextRound()
			end)
			slot0:Reset()
		end,
		Start = function (slot0)
			slot0:NextRound()
		end,
		Reset = function (slot0)
			slot0.animator:SetInteger(&quot;Round&quot;, 0)
			slot0.animator:Play(&quot;IdleA&quot;)

			slot0.roundNum = 1
		end,
		NextRound = function (slot0)
			slot0.animator:SetInteger(&quot;Round&quot;, slot0.roundNum)

			if slot0.roundNum == 3 then
				slot0.roundNum = 1
			else
				slot0.roundNum = slot0.roundNum + 1
			end
		end
	}

	slot2:Ctor()

	return slot2
end

slot52 = function(slot0, slot1)
	slot2 = {
		Ctor = function (slot0)
			slot0._tf = uv0
			slot0._event = uv1
			slot0.config = uv2.miner
			slot0.animator = GetComponent(slot0._tf, typeof(Animator))
			slot0.phyItem = GetComponent(slot0._tf, &quot;Physics2DItem&quot;)

			slot0.phyItem.CollisionEnter:AddListener(function (slot0)
				uv0:OnCollision()
			end)

			slot0.phyGrazeItem = GetComponent(findTF(slot0._tf, &quot;GrazeCollider&quot;), &quot;Physics2DItem&quot;)

			slot0.phyGrazeItem.TriggerEnter:AddListener(function (slot0)
				uv0:OnGrazeTrigger(slot0)
			end)
			slot0._event:bind(uv3, function (slot0, slot1, slot2)
				uv0.hitSpeed = slot1.speed
			end)
			slot0:Reset()
		end,
		Start = function (slot0)
		end,
		Reset = function (slot0)
			slot0.isClash = false
			slot0.hitSpeed = 0
		end,
		OnCollision = function (slot0)
			slot0.isClash = true
			slot1 = 0

			if uv0[3] &lt; slot0.hitSpeed then
				slot1 = 3
			elseif uv0[2] &lt; slot0.hitSpeed then
				slot1 = 2
			elseif uv0[1] &lt; slot0.hitSpeed then
				slot1 = 1
			end

			slot0.animator:SetInteger(&quot;Speed&quot;, slot1)
			slot0.animator:SetTrigger(&quot;Clash&quot;)
		end,
		OnGrazeTrigger = function (slot0, slot1)
			if slot1.gameObject.name ~= &quot;Ayanami&quot; then
				return
			end

			onDelayTick(function ()
				if uv0.isClash then
					return
				end

				uv0.animator:SetTrigger(&quot;Graze&quot;)
			end, 0.3)
		end
	}

	slot2:Ctor()

	return slot2
end

slot53 = function(slot0, slot1)
	slot2 = {
		Ctor = function (slot0)
			slot0._tf = uv0
			slot0._event = uv1
			slot0.config = uv2.walker
			slot0.obstacleTF = slot0._tf.parent
			slot0.bgFrontTF = findTF(slot0.obstacleTF.parent.parent, &quot;bg_front&quot;)
			slot0.animator = GetComponent(slot0._tf, typeof(Animator))
			slot0.rigbody = GetComponent(slot0._tf, &quot;Rigidbody2D&quot;)
			slot0.phyItem = GetComponent(slot0._tf, &quot;Physics2DItem&quot;)

			slot0.phyItem.CollisionEnter:AddListener(function (slot0)
				uv0:OnCollision(slot0)
			end)
			slot0._event:bind(uv3, function (slot0, slot1, slot2)
				uv0.hitSpeed = slot1.speed
			end)
			slot0._event:bind(uv4, function (slot0, slot1, slot2)
				uv0:Pause()
			end)
			slot0._event:bind(uv5, function (slot0, slot1, slot2)
				uv0:Resume()
			end)
		end,
		SetPath = function (slot0, slot1)
			slot0.pathType = slot1
		end,
		Start = function (slot0)
			slot0:WalkPath()
		end,
		Reset = function (slot0)
			setActive(slot0._tf, false)
			setLocalPosition(slot0._tf, Vector2(-1400, 0))

			slot0.rigbody.velocity = Vector2.zero
			slot0.isJumpDown = false
			slot0.isJumpUp = false
			slot0.isForwardNorth = false
			slot0.isForwardSouth = false
			slot0.hitSpeed = 0
			slot0.pathType = 0
		end,
		OnCollision = function (slot0, slot1)
			slot0.animator:SetTrigger(&quot;Clash&quot;)

			slot2 = 0

			if uv0[3] &lt; slot0.hitSpeed then
				slot2 = 3
			elseif uv0[2] &lt; slot0.hitSpeed then
				slot2 = 2
			elseif uv0[1] &lt; slot0.hitSpeed then
				slot2 = 1
			end

			slot0.animator:SetInteger(&quot;Speed&quot;, slot2)

			slot0.rigbody.velocity = Vector2.zero
		end,
		WalkPath = function (slot0)
			if slot0.pathType == uv0 or slot0.pathType == uv1 then
				setLocalPosition(slot0._tf, uv2)
				slot0._tf:SetParent(slot0.bgFrontTF, false)

				slot0.isForwardNorth = true

				slot0.animator:SetBool(&quot;IsNorth&quot;, true)
				slot0:WalkNorth()
			elseif slot0.pathType == uv3 or slot0.pathType == uv4 then
				setLocalPosition(slot0._tf, uv5)
				slot0._tf:SetParent(slot0.obstacleTF, false)

				slot0.isForwardSouth = true

				slot0.animator:SetBool(&quot;IsSouth&quot;, true)
				slot0:WalkSouth()
			end
		end,
		WalkNorth = function (slot0)
			slot0.animator:SetTrigger(&quot;WalkN&quot;)

			slot0.rigbody.velocity = Vector2(0, 1.5)
		end,
		JumpNorth = function (slot0)
			slot0.animator:SetTrigger(&quot;JumpN&quot;)

			if slot0.isJumpUp then
				slot0:WalkNorth()
			elseif slot0.pathType == uv0 then
				slot0:WalkNorthwest()
			else
				slot0:WalkNorth()
			end
		end,
		WalkNorthwest = function (slot0)
			slot0.animator:SetTrigger(&quot;WalkNW&quot;)

			slot0.rigbody.velocity = Vector2(-1.5, 1.5)
		end,
		WalkSouth = function (slot0)
			slot0.animator:SetTrigger(&quot;WalkS&quot;)

			slot0.rigbody.velocity = Vector2(0, -1.5)
		end,
		JumpSouth = function (slot0)
			slot0.animator:SetTrigger(&quot;JumpS&quot;)

			if slot0.isJumpDown then
				slot0:WalkSouth()
			elseif slot0.pathType == uv0 then
				slot0:WalkSouthwest()
			else
				slot0:WalkSouth()
			end
		end,
		WalkSouthwest = function (slot0)
			slot0.animator:SetTrigger(&quot;WalkSW&quot;)

			slot0.rigbody.velocity = Vector2(-1.5, -1.5)
		end,
		Step = function (slot0)
			if uv0 &lt; slot0._tf.anchoredPosition.y or slot1 &lt; -uv0 then
				slot0.rigbody.velocity = Vector2.zero

				return
			end

			if slot0.isForwardNorth then
				if not slot0.isJumpDown and slot1 &gt;= -470 then
					slot0.isJumpDown = true

					slot0:JumpNorth()
					onDelayTick(function ()
						uv0._tf:SetParent(uv0.obstacleTF, false)
					end, 0.3)
				end

				if not slot0.isJumpUp and slot1 &gt;= 310 then
					slot0.isJumpUp = true

					slot0:JumpNorth()
				end
			end

			if slot0.isForwardSouth then
				if not slot0.isJumpUp and slot1 &lt;= 370 then
					slot0.isJumpUp = true

					slot0:JumpSouth()
				end

				if not slot0.isJumpDown and slot1 &lt;= -420 then
					slot0.isJumpDown = true

					slot0:JumpSouth()
					onDelayTick(function ()
						uv0._tf:SetParent(uv0.bgFrontTF, false)
					end, 0.3)
				end
			end
		end,
		Pause = function (slot0)
			slot0.speedRecord = slot0.rigbody.velocity
			slot0.rigbody.velocity = Vector2.zero
			slot0.animator.speed = 0
		end,
		Resume = function (slot0)
			slot0.rigbody.velocity = slot0.speedRecord
			slot0.animator.speed = 1
		end
	}
	slot3 = 1000

	slot2:Ctor()

	return slot2
end

slot0.getUIName = function(slot0)
	return &quot;GameRoomCurlingUI&quot;
end

slot0.didEnter = function(slot0)
	slot0:initEvent()
	slot0:initData()
	slot0:initUI()
	slot0:initGameUI()
	slot0:initController()
	slot0:updateMainUI()
	slot0:openMainUI()
	slot0:AutoFitScreen()
end

slot0.AutoFitScreen = function(slot0)
	slot6 = nil
	slot6 = (1.7777777777777777 &gt; Screen.width / Screen.height or math.clamp(1080 * slot1 / 2331, 1, 2)) and math.clamp(1920 / slot1 / slot0:findTF(&quot;bg_back&quot;).rect.height, 1, 2)

	setLocalScale(slot0._tf, {
		x = slot6,
		y = slot6,
		z = slot6
	})
end

slot0.initEvent = function(slot0)
	slot0:bind(uv0, function (slot0, slot1, slot2)
		if slot1.result ~= uv0 then
			uv1:addScore(uv2[slot1.result])
		end

		slot3 = uv1

		slot3:obsFadeOut()
		onDelayTick(function ()
			uv0:nextRoundGame()
		end, uv3)
	end)
	slot0:bind(uv4, function (slot0, slot1, slot2)
		if slot1.score and slot1.score ~= 0 then
			uv0:addScore(slot1.score, slot1.pos)
		end
	end)
end

slot0.initData = function(slot0)
	if (Application.targetFrameRate or 60) &gt; 60 then
		slot1 = 60
	end

	slot0.needManualSimulate = true
	slot0.timer = Timer.New(function ()
		uv0:onTimer()

		if uv0.needManualSimulate then
			Physics2D.Simulate(1 / uv1)
		end
	end, 1 / slot1, -1)
end

slot0.initUI = function(slot0)
	slot0.clickMask = slot0:findTF(&quot;ui/click_mask&quot;)
	slot0.mainUI = slot0:findTF(&quot;ui/main_ui&quot;)
	slot0.listScrollRect = GetComponent(findTF(slot0.mainUI, &quot;item_list&quot;), typeof(ScrollRect))

	onButton(slot0, slot0:findTF(&quot;skin_btn&quot;, slot0.mainUI), function ()
		pg.m02:sendNotification(GAME.GO_SCENE, SCENE.SKINSHOP, {
			skinId = pg.mini_game[uv0:GetMGData().id].simple_config_data.skin_shop_id
		})
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;return_btn&quot;, slot0.mainUI), function ()
		uv0:emit(uv1.ON_BACK_PRESSED)
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;main_btn&quot;, slot0.mainUI), function ()
		uv0:emit(uv1.ON_HOME)
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;help_btn&quot;, slot0.mainUI), function ()
		slot0 = uv0:getGameRoomData().game_help

		pg.MsgboxMgr.GetInstance():ShowMsgBox({
			type = MSGBOX_TYPE_HELP,
			helps = uv0:getGameRoomData().game_help
		})
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;start_btn&quot;, slot0.mainUI), function ()
		uv0:readyStart()
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;rank_btn&quot;, slot0.mainUI), function ()
	end, SFX_PANEL)

	slot0.totalTimes = slot0:getGameTotalTime()

	scrollTo(slot0.listScrollRect, 0, 1 - (slot0:getGameUsedTimes() - 4 &lt; 0 and 0 or slot0:getGameUsedTimes() - 4) / (slot0.totalTimes - 4))
	onButton(slot0, slot0:findTF(&quot;right_panel/arrows_up&quot;, slot0.mainUI), function ()
		if uv0.listScrollRect.normalizedPosition.y + 1 / (uv0.totalTimes - 4) &gt; 1 then
			slot0 = 1
		end

		scrollTo(uv0.listScrollRect, 0, slot0)
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;right_panel/arrows_down&quot;, slot0.mainUI), function ()
		if uv0.listScrollRect.normalizedPosition.y - 1 / (uv0.totalTimes - 4) &lt; 0 then
			slot0 = 0
		end

		scrollTo(uv0.listScrollRect, 0, slot0)
	end, SFX_PANEL)

	slot0.countUI = slot0:findTF(&quot;ui/count_ui&quot;)
	slot0.countAnimator = GetComponent(slot0:findTF(&quot;count&quot;, slot0.countUI), typeof(Animator))
	slot0.countDft = GetOrAddComponent(slot0:findTF(&quot;count&quot;, slot0.countUI), typeof(DftAniEvent))

	slot0.countDft:SetTriggerEvent(function ()
	end)
	slot0.countDft:SetEndEvent(function ()
		setActive(uv0.countUI, false)
		uv0:startGame()
	end)

	slot0.pauseUI = slot0:findTF(&quot;ui/pause_ui&quot;)

	onButton(slot0, slot0:findTF(&quot;ad/panel/sure_btn&quot;, slot0.pauseUI), function ()
		setActive(uv0.pauseUI, false)
		uv0:resumeGame()
	end, SFX_PANEL)

	slot0.returnUI = slot0:findTF(&quot;ui/return_ui&quot;)

	onButton(slot0, slot0:findTF(&quot;ad/panel/sure_btn&quot;, slot0.returnUI), function ()
		setActive(uv0.returnUI, false)
		uv0:resumeGame()
		uv0:endGame()
	end, SFX_PANEL)
	onButton(slot0, slot0:findTF(&quot;ad/panel/cancel_btn&quot;, slot0.returnUI), function ()
		setActive(uv0.returnUI, false)
		uv0:resumeGame()
	end, SFX_PANEL)

	slot0.endUI = slot0:findTF(&quot;ui/end_ui&quot;)

	onButton(slot0, slot0:findTF(&quot;ad/panel/end_btn&quot;, slot0.endUI), function ()
		setActive(uv0.endUI, false)
		uv0:openMainUI()
	end, SFX_PANEL)

	if not slot0.handle then
		slot0.handle = UpdateBeat:CreateListener(slot0.Update, slot0)
	end

	UpdateBeat:AddListener(slot0.handle)
end

slot0.initGameUI = function(slot0)
	slot0.gameUI = slot0:findTF(&quot;ui/game_ui&quot;)
	slot0.roundTF = slot0:findTF(&quot;score_panel/round_text&quot;, slot0.gameUI)
	slot0.scoreTF = slot0:findTF(&quot;score_panel/score_text&quot;, slot0.gameUI)

	onButton(slot0, slot0:findTF(&quot;pause_btn&quot;, slot0.gameUI), function ()
		uv0:pauseGame()
		setActive(uv0.pauseUI, true)
	end)
	onButton(slot0, slot0:findTF(&quot;return_btn&quot;, slot0.gameUI), function ()
		uv0:pauseGame()
		setActive(uv0.returnUI, true)
	end)

	slot0.scoreGroup = slot0:findTF(&quot;score_group&quot;, slot0.gameUI)

	setActive(slot0:findTF(&quot;bg_front/wall&quot;), uv0)
end

slot0.initController = function(slot0)
	slot0.scene = slot0:findTF(&quot;scene&quot;)
	slot0.gridTF = slot0:findTF(&quot;ui/grid&quot;)
	slot0.player = uv0(slot0:findTF(&quot;player&quot;, slot0.scene), slot0)
	slot0.phy = slot0:findTF(&quot;Ayanami_phy&quot;, slot0.scene)
	slot0.drawDot = slot0:findTF(&quot;draw_dot&quot;, slot0.scene)
	slot0.curlingTpls = slot0:findTF(&quot;curling_Tpl&quot;, slot0.scene)
	slot0.curling = uv1(slot0.curlingTpls, slot0.player._tf, slot0)
	slot0.ofunya = uv2(slot0:findTF(&quot;bg_back/07_Ofunya&quot;), slot0)
	slot0.manjuu = uv3(slot0:findTF(&quot;bg_back/08_Manjuu&quot;), slot0)
	slot0.walker = uv4(slot0:findTF(&quot;obstacle/walker&quot;, slot0.scene), slot0)
	slot0.obsTF = slot0:findTF(&quot;scene/obstacle&quot;)
	slot0.obsCanvas = GetComponent(slot0.obsTF, typeof(CanvasGroup))
	slot0.obsTpl = slot0:findTF(&quot;scene/obstacle_Tpl&quot;)
	slot0.minerGroups = slot0:findTF(&quot;miner_groups&quot;, slot0.obsTF)
	slot0.oilGroups = slot0:findTF(&quot;oil_groups&quot;, slot0.obsTF)
	slot0.cubeGroups = slot0:findTF(&quot;cube_groups&quot;, slot0.obsTF)
end

slot0.updateMainUI = function(slot0)
	slot1 = slot0:getGameUsedTimes()
	slot2 = slot0:getGameTimes()
	slot0.totalTimes = slot0:getGameTotalTime()

	if 1 - (slot0:getGameUsedTimes() - 3 &lt; 0 and 0 or slot0:getGameUsedTimes() - 3) / (slot0.totalTimes - 4) &gt; 1 then
		slot4 = 1
	end

	scrollTo(slot0.listScrollRect, 0, slot4)
end

slot0.openMainUI = function(slot0)
	setActive(slot0.gameUI, false)
	setActive(slot0.mainUI, true)
	slot0:openCoinLayer(true)
	slot0:updateMainUI()
end

slot0.readyStart = function(slot0)
	setActive(slot0.mainUI, false)
	setActive(slot0.countUI, true)
	slot0:openCoinLayer(false)
	slot0.countAnimator:Play(&quot;count&quot;)
	pg.CriMgr.GetInstance():PlaySoundEffect_V3(uv0)
	slot0:resetGame()
end

slot0.resetGame = function(slot0)
	slot0.gameStartFlag = false
	slot0.gamePause = false
	slot0.gameEndFlag = false
	slot0.scoreNum = 0
	slot0.roundNum = 1

	slot0.player:Reset()
	slot0.curling:Reset()
	slot0.ofunya:Reset()
	slot0.manjuu:Reset()
	slot0.walker:Reset()
end

slot0.startGame = function(slot0)
	setActive(slot0.gameUI, true)
	slot0:CoordinateGrid(slot0.gridTF)

	slot0.gameStartFlag = true

	slot0.player:Start()
	slot0.curling:Start()
	slot0.ofunya:Start()
	slot0.manjuu:Start()
	slot0:staticObsStart()
	slot0:updateGameUI()
	slot0:timerStart()
end

slot0.staticObsStart = function(slot0)
	setActive(slot0.obsTF, true)

	slot0.obsCanvas.alpha = 1

	slot0.walker:Reset()

	if math.random() &lt;= uv0.walker.appear then
		setActive(slot0.walker._tf, true)
		setLocalScale(slot0.walker._tf, Vector2(uv1.walker, uv1.walker))

		slot3 = slot2.path[math.random(1, #slot2.path)]

		slot0.walker:SetPath(slot3)

		slot4 = {}

		if slot3 == uv2 then
			slot4 = {
				8,
				11,
				12,
				14,
				15,
				18,
				17,
				21
			}
		elseif slot3 == uv3 then
			slot4 = {
				5,
				9,
				10,
				14,
				15,
				19,
				20,
				24
			}
		end

		slot5 = function(slot0)
			for slot4, slot5 in ipairs(uv0) do
				if slot0 == slot5 then
					return true
				end
			end

			return false
		end

		slot6 = {}

		for slot10, slot11 in ipairs(slot0.grids) do
			if not slot5(slot10) then
				table.insert(slot6, slot11)
			end
		end

		slot0.grids = slot6

		slot0.walker:Start()
	end

	removeAllChildren(slot0.oilGroups)

	for slot6, slot7 in ipairs(uv0.oil) do
		if math.random() &lt;= slot7.appear then
			for slot12 = 1, slot7.num do
				slot13 = cloneTplTo(slot0:findTF(&quot;oil_Tpl&quot;, slot0.obsTpl), slot0.oilGroups, &quot;oil&quot;)

				setActive(slot13, true)

				slot14 = math.random(1, #slot0.grids)

				setLocalPosition(slot13, Vector2(slot0.grids[slot14].x, slot0.grids[slot14].y))
				setLocalScale(slot13, Vector2(uv1.oil, uv1.oil))
				table.remove(slot0.grids, slot14)
			end
		end
	end

	removeAllChildren(slot0.cubeGroups)

	for slot6, slot7 in ipairs(uv0.cube) do
		if math.random() &lt;= slot7.appear then
			for slot12 = 1, slot7.num do
				slot13 = cloneTplTo(slot0:findTF(&quot;cube_Tpl&quot;, slot0.obsTpl), slot0.cubeGroups, &quot;cube&quot;)

				setActive(slot13, true)

				slot14 = math.random(1, #slot0.grids)

				setLocalPosition(slot13, Vector2(slot0.grids[slot14].x, slot0.grids[slot14].y))
				setLocalScale(slot13, Vector2(uv1.cube, uv1.cube))
				table.remove(slot0.grids, slot14)
			end
		end
	end

	removeAllChildren(slot0.minerGroups)

	slot0.minerControls = {}

	for slot6, slot7 in ipairs(uv0.miner) do
		if math.random() &lt;= slot7.appear then
			for slot12 = 1, slot7.num do
				slot13 = cloneTplTo(slot0:findTF(&quot;miner_Tpl&quot;, slot0.obsTpl), slot0.minerGroups, &quot;miner&quot;)

				setActive(slot13, true)
				table.insert(slot0.minerControls, uv4(slot13, slot0))

				slot15 = math.random(1, #slot0.grids)

				setLocalPosition(slot13, Vector2(slot0.grids[slot15].x, slot0.grids[slot15].y))
				setLocalScale(slot13, Vector2(uv1.miner, uv1.miner))
				table.remove(slot0.grids, slot15)
			end
		end
	end
end

slot0.obsFadeOut = function(slot0)
	slot1 = slot0:managedTween(LeanTween.value, function ()
		setActive(uv0.obsTF, false)
	end, go(slot0.obsTF), 1, 0, 0.5)

	slot1:setOnUpdate(System.Action_float(function (slot0)
		uv0.obsCanvas.alpha = slot0
	end))
end

slot0.Update = function(slot0)
	slot0:AddDebugInput()
end

slot0.AddDebugInput = function(slot0)
	if slot0.gamePause or slot0.gameEndFlag then
		return
	end

	if IsUnityEditor then
		-- Nothing
	end
end

slot0.changeSpeed = function(slot0, slot1)
end

slot0.onTimer = function(slot0)
	slot0.curling:Step()
	slot0.walker:Step()
	slot0:updateGameUI()
end

slot0.timerStart = function(slot0)
	if not slot0.timer.running then
		slot0.timer:Start()
	end
end

slot0.timerStop = function(slot0)
	if slot0.timer.running then
		slot0.timer:Stop()
	end
end

slot0.updateGameUI = function(slot0)
	setText(slot0.scoreTF, slot0.scoreNum)
	setText(slot0.roundTF, &quot;Round &quot; .. slot0.roundNum)
end

slot0.addScore = function(slot0, slot1, slot2)
	slot3 = cloneTplTo(slot0:findTF(&quot;score_tf&quot;, slot0.gameUI), slot0.scoreGroup)

	if slot2 then
		setLocalPosition(slot3, slot2)
	else
		setLocalPosition(slot3, Vector2(432, 144))
	end

	setActive(slot3, false)
	setActive(slot3, true)
	setText(slot3, &quot;+&quot; .. slot1)

	slot0.scoreNum = slot0.scoreNum + slot1
end

slot0.pauseGame = function(slot0)
	slot0.gamePause = true

	slot0:timerStop()
	slot0:changeSpeed(0)
	slot0:pauseManagedTween()
	slot0:emit(uv0)
end

slot0.resumeGame = function(slot0)
	slot0.gamePause = false

	slot0:changeSpeed(1)
	slot0:timerStart()
	slot0:resumeManagedTween()
	slot0:emit(uv0)
end

slot0.nextRoundGame = function(slot0)
	removeAllChildren(slot0.scoreGroup)

	if slot0.roundNum == 3 then
		slot0:endGame()
	else
		slot0.roundNum = slot0.roundNum + 1

		slot0:CoordinateGrid(slot0.gridTF)
		slot0:staticObsStart()
		slot0:emit(uv0)
	end
end

slot0.endGame = function(slot0)
	if slot0.gameEndFlag then
		return
	end

	slot0:timerStop()

	slot0.gameEndFlag = true

	setActive(slot0.clickMask, true)
	slot0:managedTween(LeanTween.delayedCall, function ()
		uv0.gameEndFlag = false
		uv0.gameStartFlag = false

		setActive(uv0.clickMask, false)
		uv0:showEndUI()
	end, 0.1, nil)
end

slot0.showEndUI = function(slot0)
	setActive(slot0.endUI, true)

	slot1 = slot0.scoreNum
	slot3 = getProxy(MiniGameProxy):GetHighScore(slot0:GetMGData().id) and #slot2 &gt; 0 and slot2[1] or 0
	slot4 = slot2 and #slot2 &gt; 1 and slot2[2] or 0

	setActive(slot0:findTF(&quot;ad/panel/cur_score/new&quot;, slot0.endUI), slot3 &lt; slot1)

	if slot3 &lt;= slot1 then
		slot0:StoreDataToServer({
			slot1
		})
	end

	setText(slot0:findTF(&quot;ad/panel/highest_score&quot;, slot0.endUI), slot3)
	setText(slot0:findTF(&quot;ad/panel/cur_score&quot;, slot0.endUI), slot1)
	slot0:SendSuccess(slot1 or 0)
end

slot0.CoordinateGrid = function(slot0, slot1)
	slot2 = Vector2(150, 150)
	slot3 = slot1.rect.width
	slot4 = slot1.rect.height
	slot5 = Vector2(slot1.anchoredPosition.x - slot3 / 2, slot1.anchoredPosition.y - slot4 / 2)
	slot7 = slot4 % slot2.y / (math.modf(slot4 / slot2.y) + 1)
	slot8 = math.modf(slot3 / slot2.x)
	slot9 = slot3 % slot2.x / (slot8 + 1)
	slot0.grids = {}

	for slot13 = 1, slot8 do
		for slot17 = 1, slot6 do
			table.insert(slot0.grids, Vector2(slot5.x + slot13 * (slot9 + slot2.x) - slot2.x / 2, slot5.y + slot17 * (slot7 + slot2.y) - slot2.y / 2))
		end
	end
end

slot0.getGameTimes = function(slot0)
	return slot0:GetMGHubData().count
end

slot0.getGameUsedTimes = function(slot0)
	return slot0:GetMGHubData().usedtime
end

slot0.getUltimate = function(slot0)
	return slot0:GetMGHubData().ultimate
end

slot0.getGameTotalTime = function(slot0)
	return slot0:GetMGHubData():getConfig(&quot;reward_need&quot;)
end

slot0.onBackPressed = function(slot0)
	if not slot0.gameStartFlag then
		slot0:emit(uv0.ON_BACK_PRESSED)
	else
		if slot0.gameEndFlag then
			return
		end

		if isActive(slot0.pauseUI) then
			setActive(slot0.pauseUI, false)
		end

		slot0:pauseGame()
		setActive(slot0.returnUI, true)
	end
end

slot0.willExit = function(slot0)
	if slot0.handle then
		UpdateBeat:RemoveListener(slot0.handle)
	end

	slot0:cleanManagedTween()

	if slot0.timer and slot0.timer.running then
		slot0.timer:Stop()
	end

	Time.timeScale = 1
	slot0.timer = nil
end

return slot0
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</body>
</html>