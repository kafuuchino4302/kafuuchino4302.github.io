<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>messagecache.lua</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <h1>messagecache.lua</h1>
    <a href="index.html">返回主页</a>
    <pre><code class="language-lua">pg = pg or {}
slot0 = pg
slot0.MessageCache = class(&quot;MessageCache&quot;)
slot0.MessageCache.DEFAULT_QUEUE_LENGTH = 10000
slot0.MessageCache.CMD_KILL = &quot;CMD_KILL&quot;
slot0.MessageCache.CMD_PUSH = &quot;CMD_PUSH&quot;
slot0.MessageCache.CMD_POP = &quot;CMD_POP&quot;
slot0.MessageCache.CMD_FLUSH = &quot;CMD_FLUSH&quot;
slot0.MessageCache.OK = &quot;OK&quot;
slot0.MessageCache.QUEUE_FULL = &quot;QUEUE_FULL&quot;
slot0.MessageCache.EXCEPTION = &quot;EXCEPTION&quot;

slot1 = function(...)
	return coroutine.yield(...)
end

slot2 = function(slot0, slot1, slot2)
	if slot1 == uv0.MessageCache.CMD_PUSH then
		if slot0.cacheQueueLenLimit_ &lt;= #slot0.cacheQueue_ + slot0.curRQLen_ - slot0.curRQPos_ then
			return uv1(slot0, uv2(uv0.MessageCache.QUEUE_FULL, string.format(&quot;                    the cache limit length is set with %s, the coming message will be ignored.\n                &quot;, slot0.cacheQueueLenLimit_)))
		else
			table.insert(slot0.cacheQueue_, slot2)

			return uv1(slot0, uv2(uv0.MessageCache.OK, slot3 + 1))
		end
	elseif slot1 == uv0.MessageCache.CMD_POP then
		if slot0.curRQPos_ &lt; slot0.curRQLen_ then
			slot0.curRQPos_ = slot0.curRQPos_ + 1
			slot0.retrieveQueue_[slot0.curRQPos_] = nil

			return uv1(slot0, uv2(uv0.MessageCache.OK, slot0.retrieveQueue_[slot0.curRQPos_]))
		else
			assert(slot0.curRQLen_ &lt;= slot0.curRQPos_)

			if slot0.cacheQueue_[1] then
				slot0.retrieveQueue_ = slot0.cacheQueue_
				slot0.cacheQueue_ = slot0.retrieveQueue_
				slot0.curRQPos_ = 1
				slot0.curRQLen_ = #slot0.retrieveQueue_
				slot0.retrieveQueue_[slot0.curRQPos_] = nil

				return uv1(slot0, uv2(uv0.MessageCache.OK, slot0.retrieveQueue_[slot0.curRQPos_]))
			else
				return uv1(slot0, uv2(uv0.MessageCache.OK))
			end
		end
	elseif slot1 == uv0.MessageCache.CMD_KILL then
		slot3 = slot0.curRQPos_
		slot4 = slot0.curRQLen_
		slot5 = 1

		while slot3 &lt; slot4 do
			table.insert(slot0.cacheQueue_, slot5, slot0.retrieveQueue_[slot3])

			slot0.retrieveQueue_[slot3] = nil
			slot5 = slot5 + 1
			slot3 = slot3 + 1
		end

		slot0.curRQPos_ = 0
		slot0.curRQLen_ = 0

		return uv0.MessageCache.OK, slot0.cacheQueue_
	elseif slot1 == uv0.MessageCache.CMD_FLUSH then
		slot3 = slot0.curRQPos_
		slot4 = slot0.curRQLen_
		slot5 = 1

		while slot3 &lt; slot4 do
			table.insert(slot0.cacheQueue_, slot5, slot0.retrieveQueue_[slot3])

			slot0.retrieveQueue_[slot3] = nil
			slot5 = slot5 + 1
			slot3 = slot3 + 1
		end

		slot0.curRQPos_ = 0
		slot0.curRQLen_ = 0
		slot0.cacheQueue_ = {}

		return uv1(slot0, uv2(uv0.MessageCache.OK, slot0.cacheQueue_))
	else
		return uv1(slot0, uv2(uv0.MessageCache.EXCEPTION, string.format(&quot;unknown cmd type received %s&quot;, tostring(slot1))))
	end
end

slot3 = function(slot0)
	return uv1({
		curRQPos_ = 0,
		curRQLen_ = 0,
		cacheQueue_ = {},
		retrieveQueue_ = {},
		cacheQueueLenLimit_ = slot0 or uv0.MessageCache.DEFAULT_QUEUE_LENGTH
	}, uv2(uv0.MessageCache.OK))
end

slot0.MessageCache.Ctor = function(slot0, slot1, slot2)
	slot0._name = slot1
	slot0._thread = coroutine.create(uv0)
	slot3, slot4 = coroutine.resume(slot0._thread, slot2)

	assert(slot4 == uv1.MessageCache.OK)
end

slot0.MessageCache.Push = function(slot0, ...)
	if coroutine.status(slot0._thread) == &quot;suspended&quot; then
		slot2, slot3, slot4 = coroutine.resume(slot0._thread, uv0.MessageCache.CMD_PUSH, {
			...
		})

		if slot2 then
			return slot3, slot4
		else
			return uv0.MessageCache.EXCEPTION, slot3
		end
	else
		return uv0.MessageCache.EXCEPTION, string.format(&quot;current thread status %s,\n            maybe the MessageCache:Destroy() is called before the Push operation.&quot;, slot1)
	end
end

slot0.MessageCache.Pop = function(slot0)
	if coroutine.status(slot0._thread) == &quot;suspended&quot; then
		slot2, slot3, slot4 = coroutine.resume(slot0._thread, uv0.MessageCache.CMD_POP)

		if slot2 then
			if slot3 == uv0.MessageCache.OK and slot4 ~= nil then
				return slot3, unpack(slot4)
			else
				return slot3, slot4
			end
		else
			return uv0.MessageCache.EXCEPTION, slot3
		end
	else
		return uv0.MessageCache.EXCEPTION, string.format(&quot;current thread status %s,\n            maybe the MessageCache:Destroy() is called before the Pop operation.&quot;, slot1)
	end
end

slot0.MessageCache.Flush = function(slot0)
	if coroutine.status(slot0._thread) == &quot;suspended&quot; then
		slot2, slot3, slot4 = coroutine.resume(slot0._thread, uv0.MessageCache.CMD_FLUSH)

		if slot2 then
			return slot3, slot4
		else
			return uv0.MessageCache.EXCEPTION, slot3
		end
	else
		return uv0.MessageCache.EXCEPTION, string.format(&quot;current thread status %s,\n            maybe the MessageCache:Destroy() is called before the Destroy operation.&quot;, slot1)
	end
end

slot0.MessageCache.Destroy = function(slot0)
	if coroutine.status(slot0._thread) == &quot;suspended&quot; then
		slot2, slot3, slot4 = coroutine.resume(slot0._thread, uv0.MessageCache.CMD_KILL)

		if slot2 then
			return slot3, slot4
		else
			return uv0.MessageCache.EXCEPTION, slot3
		end
	else
		return uv0.MessageCache.EXCEPTION, string.format(&quot;current thread status %s,\n            maybe the MessageCache:Destroy() is called before the Destroy operation.&quot;, slot1)
	end
end
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</body>
</html>