<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>re.lua</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
</head>
<body>
    <h1>re.lua</h1>
    <a href="index.html">返回主页</a>
    <pre><code class="language-lua">slot0 = tonumber
slot1 = type
slot2 = print
slot3 = error
slot4 = setmetatable
slot7 = getmetatable(require(&quot;lpeg&quot;).P(0))

if _VERSION == &quot;Lua 5.2&quot; then
	_ENV = nil
end

slot9 = slot5.P(1)
slot10 = {
	nl = slot5.P(&quot;\n&quot;)
}
slot11, slot12, slot13 = nil

slot14 = function()
	uv0.locale(uv1)

	uv1.a = uv1.alpha
	uv1.c = uv1.cntrl
	uv1.d = uv1.digit
	uv1.g = uv1.graph
	uv1.l = uv1.lower
	uv1.p = uv1.punct
	uv1.s = uv1.space
	uv1.u = uv1.upper
	uv1.w = uv1.alnum
	uv1.x = uv1.xdigit
	uv1.A = uv2 - uv1.a
	uv1.C = uv2 - uv1.c
	uv1.D = uv2 - uv1.d
	uv1.G = uv2 - uv1.g
	uv1.L = uv2 - uv1.l
	uv1.P = uv2 - uv1.p
	uv1.S = uv2 - uv1.s
	uv1.U = uv2 - uv1.u
	uv1.W = uv2 - uv1.w
	uv1.X = uv2 - uv1.x
	uv3 = {}
	uv4 = {}
	uv5 = {}
	slot0 = {
		__mode = &quot;v&quot;
	}

	uv6(uv3, slot0)
	uv6(uv4, slot0)
	uv6(uv5, slot0)
end

slot14()

slot15 = slot5.P(function (slot0, slot1)
	uv0(slot1, slot0:sub(1, slot1 - 1))

	return slot1
end)

slot16 = function(slot0, slot1)
	if not (slot1 and slot1[slot0]) then
		uv0(&quot;undefined name: &quot; .. slot0)
	end

	return slot2
end

slot17 = function(slot0, slot1)
	uv0((&quot;pattern error near &#x27;%s&#x27;&quot;):format(#slot0 &lt; slot1 + 20 and slot0:sub(slot1) or slot0:sub(slot1, slot1 + 20) .. &quot;...&quot;), 2)
end

slot19 = function(slot0, slot1, slot2)
	if uv0(slot2) ~= &quot;string&quot; then
		return nil
	end

	if slot0:sub(slot1, #slot2 + slot1 - 1) == slot2 then
		return slot3
	else
		return nil
	end
end

slot20 = (slot10.space + &quot;--&quot; * (slot9 - slot10.nl)^0)^0
slot21 = slot5.R(&quot;AZ&quot;, &quot;az&quot;, &quot;__&quot;) * slot5.R(&quot;AZ&quot;, &quot;az&quot;, &quot;__&quot;, &quot;09&quot;)^0
slot22 = slot20 * &quot;&lt;-&quot;
slot21 = slot5.C(slot21)
slot24 = slot21 * slot5.Carg(1)
slot25 = slot5.C(slot5.R(&quot;09&quot;)^1) * slot20 / slot0
slot26 = &quot;&#x27;&quot; * slot5.C((slot9 - &quot;&#x27;&quot;)^0) * &quot;&#x27;&quot; + &quot;\&quot;&quot; * slot5.C((slot9 - &quot;\&quot;&quot;)^0) * &quot;\&quot;&quot;
slot27 = &quot;%&quot; * slot24 / function (slot0, slot1)
	if not (slot1 and slot1[slot0] or uv0[slot0]) then
		uv1(&quot;name &#x27;&quot; .. slot0 .. &quot;&#x27; undefined&quot;)
	end

	return slot2
end
slot29 = slot27 + slot5.Cs(slot9 * slot5.P(&quot;-&quot;) / &quot;&quot; * (slot9 - &quot;]&quot;)) / slot6.R + slot5.C(slot9)
slot35 = slot20 * slot5.Cg(slot5.Cc(false), &quot;G&quot;) * slot5.P({
	&quot;Exp&quot;,
	Exp = slot20 * (slot5.V(&quot;Grammar&quot;) + slot5.Cf(slot5.V(&quot;Seq&quot;) * (&quot;/&quot; * slot20 * slot5.V(&quot;Seq&quot;))^0, slot7.__add)),
	Seq = slot5.Cf(slot5.Cc(slot5.P(&quot;&quot;)) * slot5.V(&quot;Prefix&quot;)^0, slot7.__mul) * (#(slot5.P(&quot;/&quot;) + &quot;)&quot; + &quot;}&quot; + &quot;:}&quot; + &quot;~}&quot; + &quot;|}&quot; + slot21 * slot22 + -1) + slot17),
	Prefix = &quot;&amp;&quot; * slot20 * slot5.V(&quot;Prefix&quot;) / slot7.__len + &quot;!&quot; * slot20 * slot5.V(&quot;Prefix&quot;) / slot7.__unm + slot5.V(&quot;Suffix&quot;),
	Suffix = slot5.Cf(slot5.V(&quot;Primary&quot;) * slot20 * ((slot5.P(&quot;+&quot;) * slot5.Cc(1, slot7.__pow) + slot5.P(&quot;*&quot;) * slot5.Cc(0, slot7.__pow) + slot5.P(&quot;?&quot;) * slot5.Cc(-1, slot7.__pow) + &quot;^&quot; * (slot5.Cg(slot25 * slot5.Cc(function (slot0, slot1)
		slot2 = uv0.P(true)

		while slot1 &gt;= 1 do
			if slot1 % 2 &gt;= 1 then
				slot2 = slot2 * slot0
			end

			slot0 = slot0 * slot0
			slot1 = slot1 / 2
		end

		return slot2
	end)) + slot5.Cg(slot5.C(slot5.S(&quot;+-&quot;) * slot5.R(&quot;09&quot;)^1) * slot5.Cc(slot7.__pow))) + &quot;-&gt;&quot; * slot20 * (slot5.Cg((slot26 + slot25) * slot5.Cc(slot7.__div)) + slot5.P(&quot;{}&quot;) * slot5.Cc(nil, slot5.Ct) + slot5.Cg(slot24 / slot16 * slot5.Cc(slot7.__div))) + &quot;=&gt;&quot; * slot20 * slot5.Cg(slot24 / slot16 * slot5.Cc(slot5.Cmt))) * slot20)^0, function (slot0, slot1, slot2)
		return slot2(slot0, slot1)
	end),
	Primary = &quot;(&quot; * slot5.V(&quot;Exp&quot;) * &quot;)&quot; + slot26 / slot6.P + &quot;[&quot; * slot5.C(slot5.P(&quot;^&quot;)^-1) * slot5.Cf(slot29 * (slot29 - &quot;]&quot;)^0, slot7.__add) / function (slot0, slot1)
		return slot0 == &quot;^&quot; and uv0 - slot1 or slot1
	end * &quot;]&quot; + slot27 + &quot;{:&quot; * (slot21 * &quot;:&quot; + slot5.Cc(nil)) * slot5.V(&quot;Exp&quot;) * &quot;:}&quot; / function (slot0, slot1)
		return uv0.Cg(slot1, slot0)
	end + &quot;=&quot; * slot21 / function (slot0)
		return uv0.Cmt(uv0.Cb(slot0), uv1)
	end + slot5.P(&quot;{}&quot;) / slot6.Cp + &quot;{~&quot; * slot5.V(&quot;Exp&quot;) * &quot;~}&quot; / slot6.Cs + &quot;{|&quot; * slot5.V(&quot;Exp&quot;) * &quot;|}&quot; / slot6.Ct + &quot;{&quot; * slot5.V(&quot;Exp&quot;) * &quot;}&quot; / slot6.C + slot5.P(&quot;.&quot;) * slot5.Cc(slot9) + (slot21 * -slot22 + &quot;&lt;&quot; * slot21 * &quot;&gt;&quot;) * slot5.Cb(&quot;G&quot;) / function (slot0, slot1)
		if not slot1 then
			uv0(&quot;rule &#x27;&quot; .. slot0 .. &quot;&#x27; used outside a grammar&quot;)
		else
			return uv1.V(slot0)
		end
	end,
	Definition = slot21 * slot22 * slot5.V(&quot;Exp&quot;),
	Grammar = slot5.Cg(slot5.Cc(true), &quot;G&quot;) * slot5.Cf(slot5.V(&quot;Definition&quot;) / function (slot0, slot1)
		return uv0({
			slot0
		}, slot0, slot1)
	end * slot5.Cg(slot5.V(&quot;Definition&quot;))^0, function (slot0, slot1, slot2)
		if slot0[slot1] then
			uv0(&quot;&#x27;&quot; .. slot1 .. &quot;&#x27; already defined as a rule&quot;)
		else
			slot0[slot1] = slot2
		end

		return slot0
	end) / slot6.P
}) / slot6.P * (-slot9 + slot17)
slot40 = {
	compile = function (slot0, slot1)
		if uv0.type(slot0) == &quot;pattern&quot; then
			return slot0
		end

		if not uv1:match(slot0, 1, slot1) then
			uv2(&quot;incorrect pattern&quot;, 3)
		end

		return slot2
	end,
	match = function (slot0, slot1, slot2)
		if not uv0[slot1] then
			uv0[slot1] = uv1(slot1)
		end

		return slot3:match(slot0, slot2 or 1)
	end,
	find = function (slot0, slot1, slot2)
		if not uv0[slot1] then
			uv0[slot1] = uv2.P({
				uv2.Cp() * uv1(slot1) / 0 * uv2.Cp() + 1 * uv2.V(1)
			})
		end

		slot4, slot5 = slot3:match(slot0, slot2 or 1)

		if slot4 then
			return slot4, slot5 - 1
		else
			return slot4
		end
	end,
	gsub = function (slot0, slot1, slot2)
		slot3 = uv0[slot1] or {}
		uv0[slot1] = slot3

		if not slot3[slot2] then
			slot3[slot2] = uv2.Cs((uv1(slot1) / slot2 + 1)^0)
		end

		return slot4:match(slot0)
	end,
	updatelocale = slot14
}

if slot8 == &quot;Lua 5.1&quot; then
	-- Nothing
end

return slot40
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lua.min.js"></script>
</body>
</html>